// services/HabitService.ts
import {
  UserActions,
  HabitActions,
  HabitLogActions,
  MoodActions,
  NotificationActions,
  AchievementActions,
  UserAnswerActions,
} from "../actions";

// ============================================================================
// HABIT SERVICE - Business Logic Layer
// ============================================================================
export class HabitService {
  private habitActions = new HabitActions();
  private habitLogActions = new HabitLogActions();
  private notificationActions = new NotificationActions();
  private achievementActions = new AchievementActions();
  private userActions = new UserActions();

  /**
   * Complete a habit for today
   */
  async completeHabit(habitId: number, userId: number, note?: string, mood?: string) {
    // Get the habit
    const habit = await this.habitActions.getHabitById(habitId, userId);

    // Create log entry
    const log = await this.habitLogActions.createLog({
      habitId,
      userId,
      status: "completed",
      logDate: new Date(),
      note: note || "",
      mood: mood || "",
      value: 1,
      autoGenerated: false
    });

    // Calculate new streak
    const streak = await this.calculateStreak(habitId, userId);
    await this.habitActions.updateStreak(habitId, userId, streak);

    // Check for achievements
    await this.checkAchievements(userId, habitId, streak);

    return {
      log,
      streak,
      habit: await this.habitActions.getHabitById(habitId, userId),
    };
  }

  /**
   * Calculate current streak for a habit
   */
  async calculateStreak(habitId: number, userId: number): Promise<number> {
    const logs = await this.habitLogActions.getHabitLogs(habitId, userId, 365);
    
    let streak = 0;
    let checkDate = new Date();
    checkDate.setHours(0, 0, 0, 0);

    // Count backwards from today
    for (let i = 0; i < logs.length; i++) {
      const logDate = new Date(logs[i].logDate);
      logDate.setHours(0, 0, 0, 0);

      if (logDate.getTime() === checkDate.getTime() && logs[i].status === "completed") {
        streak++;
        checkDate.setDate(checkDate.getDate() - 1);
      } else if (logDate.getTime() < checkDate.getTime()) {
        break;
      }
    }

    return streak;
  }

  /**
   * Check and unlock achievements
   */
  async checkAchievements(userId: number, habitId: number, streak: number) {
    const achievements = [];

    // Streak achievements
    if (streak === 7) {
      achievements.push(
        await this.achievementActions.unlockAchievement({
          userId,
          key: "7_DAY_STREAK",
          title: "Week Warrior",
          description: "Completed a habit for 7 days in a row!",
          icon: "🔥",
          points: 50,
          type: "streak",
          linkedHabitId: habitId,
          achievedAt: new Date()
        })
      );
    }

    if (streak === 30) {
      achievements.push(
        await this.achievementActions.unlockAchievement({
          userId,
          key: "30_DAY_STREAK",
          title: "Monthly Master",
          description: "Completed a habit for 30 days in a row!",
          icon: "🏆",
          points: 200,
          type: "streak",
          linkedHabitId: habitId,
          achievedAt: new Date()
        })
      );
    }

    if (streak === 100) {
      achievements.push(
        await this.achievementActions.unlockAchievement({
          userId,
          key: "100_DAY_STREAK",
          title: "Centurion",
          description: "Completed a habit for 100 days in a row!",
          icon: "👑",
          points: 1000,
          type: "streak",
          linkedHabitId: habitId,
          achievedAt: new Date()
        })
      );
    }

    // Total completion achievements
    const user = await this.userActions.getUserById(userId);
    if (user.totalCompletions === 50) {
      achievements.push(
        await this.achievementActions.unlockAchievement({
          userId,
          key: "50_COMPLETIONS",
          title: "Getting Started",
          description: "Completed 50 habits in total!",
          icon: "⭐",
          points: 100,
          type: "completion",
          achievedAt: new Date()
        })
      );
    }

    if (user.totalCompletions === 500) {
      achievements.push(
        await this.achievementActions.unlockAchievement({
          userId,
          key: "500_COMPLETIONS",
          title: "Habit Hero",
          description: "Completed 500 habits in total!",
          icon: "💪",
          points: 500,
          type: "completion",
          achievedAt: new Date()
        })
      );
    }

    // Habit count achievements
    if (user.totalHabitsCreated === 5) {
      achievements.push(
        await this.achievementActions.unlockAchievement({
          userId,
          key: "5_HABITS_CREATED",
          title: "Building Momentum",
          description: "Created 5 habits!",
          icon: "🌱",
          points: 25,
          type: "habit_count",
          achievedAt: new Date()
        })
      );
    }

    return achievements.filter(Boolean);
  }

  /**
   * Get habit dashboard data
   */
  async getHabitDashboard(userId: number) {
    const habits = await this.habitActions.getActiveHabits(userId);
    const todaysLogs = await this.habitLogActions.getTodaysLogs(userId);
    const user = await this.userActions.getUserById(userId);
    
    const completedToday = todaysLogs.filter((l) => l.status === "completed").length;
    const totalActive = habits.length;

    return {
      habits,
      todaysProgress: {
        completed: completedToday,
        total: totalActive,
        percentage: totalActive > 0 ? (completedToday / totalActive) * 100 : 0,
      },
      stats: {
        totalHabits: user.totalHabitsCreated,
        totalCompletions: user.totalCompletions,
        currentStreak: user.streakCurrent,
        longestStreak: user.streakLongest,
      },
    };
  }

  /**
   * Get weekly statistics
   */
  async getWeeklyStats(userId: number) {
    const endDate = new Date();
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - 7);

    const logs = await this.habitLogActions.getLogsByDateRange(
      userId,
      startDate,
      endDate
    );

    const dayStats = [];
    for (let i = 0; i < 7; i++) {
      const date = new Date(startDate);
      date.setDate(date.getDate() + i);
      date.setHours(0, 0, 0, 0);

      const dayLogs = logs.filter((log) => {
        const logDate = new Date(log.logDate);
        logDate.setHours(0, 0, 0, 0);
        return logDate.getTime() === date.getTime();
      });

      const completed = dayLogs.filter((l) => l.status === "completed").length;
      const total = dayLogs.length;

      dayStats.push({
        date,
        completed,
        total,
        percentage: total > 0 ? (completed / total) * 100 : 0,
      });
    }

    return dayStats;
  }

  /**
   * Generate missing logs (for habits that weren't completed)
   */
  async generateMissedLogs(userId: number) {
    const habits = await this.habitActions.getActiveHabits(userId);
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    for (const habit of habits) {
      // Check if log exists for today
      const todaysLogs = await this.habitLogActions.getTodaysLogs(userId);
      const existingLog = todaysLogs.find((l) => l.habitId === habit.id);

      if (!existingLog) {
        // Create missed log
        await this.habitLogActions.createLog({
          habitId: habit.id,
          userId,
          status: "missed",
          logDate: today,
          note: "",
          mood: "😭",
          value: 0,
          autoGenerated: true
        });

        // Reset streak
        await this.habitActions.updateStreak(habit.id, userId, 0);
      }
    }
  }

  /**
   * Get habit insights
   */
  async getHabitInsights(habitId: number, userId: number) {
    const habit = await this.habitActions.getHabitById(habitId, userId);
    const logs = await this.habitLogActions.getHabitLogs(habitId, userId, 90);
    const stats = await this.habitLogActions.getCompletionStats(userId, habitId);

    // Calculate best day of week
    const dayCount: Record<string, number> = {};
    logs
      .filter((l) => l.status === "completed")
      .forEach((log) => {
        const day = new Date(log.logDate).toLocaleDateString("en-US", { weekday: "long" });
        dayCount[day] = (dayCount[day] || 0) + 1;
      });

    const bestDay = Object.entries(dayCount).sort((a, b) => b[1] - a[1])[0];

    return {
      habit,
      stats,
      insights: {
        bestDay: bestDay ? bestDay[0] : "None yet",
        avgCompletionsPerWeek: Math.round((stats.completed / 90) * 7),
        consistency: stats.completionRate,
      },
    };
  }
}





// Export all services
export const habitService = new HabitService();